const { Client, GatewayIntentBits, SlashCommandBuilder, PermissionFlagsBits } = require('discord.js');
const fs = require('fs');

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent
  ]
});

const TOKEN = process.env.DISCORD_TOKEN;
const OWNER_ID = '1424707396395339776';  // â† your Discord user ID (only you can use commands)
const KEYS_FILE = './keys.json';

// Load or initialize keys
let keys = {};
if (fs.existsSync(KEYS_FILE)) {
  keys = JSON.parse(fs.readFileSync(KEYS_FILE, 'utf8'));
}

function saveKeys() {
  fs.writeFileSync(KEYS_FILE, JSON.stringify(keys, null, 2));
}

client.once('ready', async () => {
  console.log(`Bot online: ${client.user.tag}`);

  // Register commands
  const genCmd = new SlashCommandBuilder()
    .setName('genkey')
    .setDescription('Generate a key with custom uses & expiration')
    .addIntegerOption(opt => opt.setName('uses').setDescription('Max uses (blank = unlimited)').setRequired(false).setMinValue(1))
    .addIntegerOption(opt => opt.setName('hours').setDescription('Hours until expiry (blank = never)').setRequired(false).setMinValue(1))
    .setDefaultMemberPermissions(PermissionFlagsBits.Administrator);

  const deactCmd = new SlashCommandBuilder()
    .setName('deactivate-key')
    .setDescription('Deactivate a key')
    .addStringOption(opt => opt.setName('key').setDescription('The key to deactivate').setRequired(true));

  const listCmd = new SlashCommandBuilder()
    .setName('list-keys')
    .setDescription('List all active keys');

  await client.application.commands.create(genCmd);
  await client.application.commands.create(deactCmd);
  await client.application.commands.create(listCmd);

  console.log('Commands registered: /genkey, /deactivate-key, /list-keys');
});

client.on('interactionCreate', async interaction => {
  if (!interaction.isCommand()) return;

  // Only your ID can use these commands
  if (interaction.user.id !== OWNER_ID) {
    return interaction.reply({ content: 'Only the bot owner can use these commands.', ephemeral: true });
  }

  if (interaction.commandName === 'genkey') {
    const maxUses = interaction.options.getInteger('uses');
    const hours = interaction.options.getInteger('hours');

    const part1 = Math.random().toString(36).slice(2, 7).toUpperCase();
    const part2 = Math.random().toString(36).slice(2, 7).toUpperCase();
    const key = `FED-${part1}-${part2}`;

    let expires = null;
    if (hours) {
      expires = Date.now() + (hours * 60 * 60 * 1000);
    }

    keys[key] = {
      active: true,
      remainingUses: maxUses || null,
      expires: expires,
      generatedAt: Date.now(),
      generatedBy: interaction.user.tag
    };

    saveKeys();

    let msg = `**Key generated & activated:**\n\`\`\`${key}\`\`\``;
    msg += `\nUses allowed: ${maxUses ? maxUses : 'unlimited'}`;
    msg += `\nExpires: ${hours ? `in ${hours} hours` : 'never'}`;

    await interaction.reply({ content: msg, ephemeral: true });
  }

  else if (interaction.commandName === 'deactivate-key') {
    const keyToDeact = interaction.options.getString('key').trim().toUpperCase();

    if (keys[keyToDeact]) {
      keys[keyToDeact].active = false;
      saveKeys();
      await interaction.reply({ content: `Key **${keyToDeact}** deactivated.`, ephemeral: true });
    } else {
      await interaction.reply({ content: `Key **${keyToDeact}** not found.`, ephemeral: true });
    }
  }

  else if (interaction.commandName === 'list-keys') {
    if (Object.keys(keys).length === 0) {
      return interaction.reply({ content: 'No active keys yet.', ephemeral: true });
    }

    let msg = '**Active Keys:**\n\n';
    for (const [key, info] of Object.entries(keys)) {
      if (!info.active) continue;
      msg += `**${key}**\n`;
      msg += `Uses left: ${info.remainingUses !== null ? info.remainingUses : 'unlimited'}\n`;
      msg += `Expires: ${info.expires ? new Date(info.expires).toLocaleString() : 'never'}\n`;
      msg += `Generated by: ${info.generatedBy}\n\n`;
    }

    await interaction.reply({ content: msg, ephemeral: true });
  }
});

client.login(TOKEN);
